#!/usr/bin/env php
<?php

if (isset($argv[1]) && $argv[1] == '--script') {
    $script = true;
} else {
    $script = false;
}

// Update
mexec('git fetch --tags --all --prune');
nvie($script);
die();

while (true) {
    $cmd = readline('$');

    switch ($cmd) {
    case 'help':
        echo "tag: Tag Analysis\n";
        break;
    case 'tag':
        interface_tags();
        break;
    case 'exit':
        exit(0);
    }
}

function prompt_boolean($question) {
    $cmd = readline($question . ' [y/N]');

    if ($cmd == 'Y' | $cmd == 'y') {
        return true;
    }

    return false;
}

function prompt_multi($question, $options) {
    $cmd = readline($question . ' [' . implode('/', $options) . ']');

    if (in_array($cmd, $options)) {
        return $cmd;
    }

    return prompt_multi($question, $options);
}

function interface_tags() {
    foreach (get_nonremote_tags() as $tag) {
        if (prompt_boolean($tag . ' does not exist remotely. Delete ' . $tag . '?')) {
            mexec('git tag -d %s', $tag);
        }
    }

    foreach (get_tags_not_in_master() as $tag) {
        $cmd = prompt_multi($tag . ' is not merged into master. (merge, delete, skip)', array('m', 'd', 's'));

        switch ($cmd) {
        case 's':
            continue;
            break;
        case 'd':
            $c = cexec('git push origin %s', ':' . $tag)->cexec('git tag -d %s', $tag);
            if ($c instanceof BashMagicFail) {
                echo "Deletion failed.\n";
            }
            break;
        case 'm':
            $c = cexec('git checkout master')
                ->cexec('git pull --rebase origin master')
                ->cexec('git merge %s', $tag);
            if ($c instanceof BashMagicFail) {
                echo "Merging failed.\n";
            }
            break;
        }
    }
}


function get_tags_not_in_master() {
    $tags = array();

    foreach (get_tags() as $tag) {
        $c = get_tag_commit($tag);
        $b = get_branches_for_commit($c);

        if (!in_array('master', $b)) {
            $tags[] = $tag;
        }
    }

    return $tags;
}

function nvie($fix_it = false) {
$cmds = array('#!/bin/bash', 'set -e');
foreach (get_tags_not_in_master() as $tag) {
    echo 'Tag: ' . $tag . ' is not in master.' . "\n";
    $cmds[] = 'echo "Deleting tag: ' . $tag . '"';
    $cmds[] = 'git push origin :' . $tag;
    $cmds[] = 'git tag -d ' . $tag;
}

foreach (get_nonremote_tags() as $tag) {
    $cmds[] = 'git tag -d ' . $tag;
}

echo "--\n";
$segments = get_organized_branches();
foreach ($segments as $base => $branches) {
    foreach ($branches as $branch) {
        $commits = get_branch_updown($base, $branch);
        if ($commits) {
            $count = count($commits);
            echo "$branch is behind $base by $count commits.\n";
            if ($count > 1000) {
                echo "$branch is behind $base too far to resolve automatically.\n";
                continue;
            }
            $cmds[] = 'echo "Bringing ' . $branch . ' up to date with ' . $base . '"';
            $cmds[] = 'git checkout ' . $base;
            $cmds[] = 'git pull --rebase origin ' . $base;
            $cmds[] = 'git checkout ' . $branch;
            $cmds[] = 'git pull --rebase origin ' . $branch;
            $cmds[] = 'git merge ' . $base;
            $cmds[] = 'git push origin ' . $branch;
        }
    }
}

echo "--\n";
foreach (get_branches_nonahead() as $branch) {
    echo "$branch should be deleted; has been merged in to develop or master." . "\n";
    $cmds[] = 'echo "Deleting branch: ' . $branch . '"';
    $cmds[] = 'git push origin :' . $branch;
    $cmds[] = 'git branch -d ' . $branch;
}

echo "--\n";
foreach (get_topic_branches() as $branch) {
    foreach (validate_branch_name($branch) as $error) {
        echo $error . "\n";
    }
}
if ($fix_it) {
echo '--' . "\r\n";
echo "The following script should fix most problems:\n";
foreach ($cmds as $cmd) {
    echo $cmd . "\n";
}
}
}

/**
 * Get tags taht exist locally, and not remotely.
 * @return array of tags.
 */
function get_nonremote_tags()
{
    return array_diff(get_tags(), get_remote_tags());
}
/**
 * Get a list of branches not ahead of their parent.
 * @return array
 */
function get_branches_nonahead()
{
    $branches = array();
    foreach (array_merge(get_hotfix_branches(), get_release_branches()) as $branch) {
        if (0 === count(get_branch_updown($branch, 'master'))) {
            $branches[] = $branch;
        }
    }

    foreach (get_topic_branches() as $branch) {
        if (0 === count(get_branch_updown($branch, 'develop'))) {
            $branches[] = $branch;
        }
    }

    return $branches;
}

/**
 * Get errors for a branch name
 * @string name $branch The name of the branch
 * @return array An array of errors, array() if there are no errors.
 */
function validate_branch_name($branch)
{
    $errors = array();

    if (strpos($branch, '_') !== false) {
        $errors[] = $branch . ' has an underscore, and should use dashes.';
    }

    if ($branch !== strtolower($branch)) {
        $errors[] = $branch . ' should be all lowercase.';
    }

    $bits = explode('-', str_replace('_', '-', $branch));
    if (!isset($bits[1]) || !is_numeric($bits[1])) {
        $errors[] = $branch . ' is not associated with a ticket.';
    }

    return $errors;
}

function get_branch_updown($base, $branch) {
    return mexeclist('git rev-list %s %s', 'origin/' . $base, '^origin/' . $branch);
}

function get_branches_for_commit($commit) {
    return mexeclist('git branch --contains %s', $commit);
}

function get_tags() {
    return mexeclist('git tag');
}

function get_remote_tags() {
    $m = mexeclist('git ls-remote --tags origin | awk \'{print $2}\'');

    return array_map(function($m) { return str_replace('refs/tags/', '', $m); }, $m);
}

function get_tag_commit($tag) {
    return trim(mexec('git rev-list -1 %s', $tag));
}

function get_hotfix_branches() {
    $b = get_branches();

    $r = array();

    foreach ($b as $branch) {
        if (substr($branch, 0, 7) == 'hotfix-') {
            $r[$branch]    = $branch;
        }
    }

    return array_values($r);
}

function get_release_branches() {
    $b = get_branches();

    $r = array();

    foreach ($b as $branch) {
        if (substr($branch, 0, 7) == 'release-') {
            $r[$branch]    = $branch;
        }
    }

    return array_values($r);
}

function get_topic_branches() {
    $b = get_branches();

    $r = array();

    foreach ($b as $branch) {
        if ($branch == 'master') {
            continue;
        } elseif ($branch == 'develop') {
            continue;
        } elseif (substr($branch, 0, 7) == 'hotfix-') {
            continue;
        } elseif (substr($branch, 0, 7) == 'release-') {
            continue;
        } else {
            $r[$branch] = $branch;
        }
    }

    return array_values($r);;
}

function get_organized_branches() {
    $b = get_branches();

    $types = array('master' => array(), 'develop' => array());

    foreach ($b as $branch) {
        if ($branch == 'master') {
            continue;
        } elseif ($branch == 'develop') {
            $types['master'][$branch]    = $branch;
        } elseif (substr($branch, 0, 7) == 'hotfix-') {
            $types['master'][$branch]    = $branch;
        } elseif (substr($branch, 0, 7) == 'release-') {
            $types['master'][$branch]    = $branch;
        } else {
            $types['develop'][]          = $branch;
        }
    }

    return $types;
}

function get_branches() {
    $b = mexeclist('git branch -r');
    $b = array_map('trim_origin', $b);

    return $b;
}

function trim_origin($name) {
    $r = explode('/', $name);
    return end($r);
}

function trim_asterisk($name) {
    return str_replace('*', '', $name);
}

function mexeclist() {
    $e = call_user_func_array('mexec', func_get_args());

    $e = explode("\n", $e);

    // Pull out the asterisk
    $e = array_map('trim_asterisk', $e);

    // Trim off whitespace
    $e = array_map('trim', $e);

    // Remove the empty elements
    $e = array_filter($e);


    return $e;
}

function mexec() {
   $cmd = call_user_func_array('mexecparse', func_get_args());
    return shell_exec($cmd);
}

function mexecparse() {
    $args = func_get_args();

    $cmd = array_shift($args);
    foreach ($args as $k => $arg) {
        $args[$k] = escapeshellarg($arg);
    }

    array_unshift($args, $cmd);
    $cmd = call_user_func_array('sprintf', $args);

    return $cmd;
}
function mexecbool() {
    $cmd = call_user_func_array('mexecparse', func_get_args());

    exec($cmd, $output, $return);

    return $return == 0;
}

class BashMagic {
    public function cexec() {
        $args = func_get_args();

        if (isset($args[0]) && is_array($args[0])) {
            $args = $args[0];
        }

        $cmd = self::parse($args);

        exec($cmd, $output, $return);

        var_dump($cmd, $return);

        if ($return == 0) {
            return new BashMagic();
        } else {
            return new BashMagicFail();
        }
    }

    protected static function parse($args) {
        $cmd = array_shift($args);
        $args = array_filter($args, 'escapeshellarg');
        array_unshift($args, $cmd);

        $cmd = call_user_func_array('sprintf', $args);

        return $cmd;
    }
}

class BashMagicFail extends BashMagic {
    public function cexec() {
        return new BashMagicFail();
    }
}

function cexec() {
    $c = new BashMagic();

    return call_user_func_array(array($c, 'cexec'), func_get_args());
}
